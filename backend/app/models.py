import uuid

from datetime import datetime
from enum import Enum
from sqlmodel import JSON, Column, Field, Relationship, SQLModel

# Enums

class CallStatus(str, Enum):
    """Status of a call through the processing pipeline."""

    UPLOADED = "uploaded"
    TRANSCRIBING = "transcribing"
    TRANSCRIBED = "transcribed"
    ANALYZING = "analyzing"
    COMPLETED = "completed"
    FAILED = "failed"


class InsightType(str, Enum):
    """Types of insights that can be extracted from a call."""

    OBJECTION = "objection"
    QUESTION = "question"
    COMMITMENT = "commitment"
    KEY_MOMENT = "key_moment"
    SENTIMENT = "sentiment"
    SUMMARY = "summary"

# DB Models

class Call(SQLModel, table=True):
    """
    Represents an uploaded sales call recording.

    This is the central entity - Transcripts and Insights hang off of it.
    """

    id: int | None = Field(default=None, primary_key=True)
    filename: str = Field(index=True, description="UUID-based stored filename")
    original_filename: str = Field(description="Original filename from upload")
    file_path: str = Field(description="Path to audio file on disk/S3")
    file_size: int = Field(description="File size in bytes")
    status: CallStatus = Field(
        default=CallStatus.UPLOADED,
        index=True,
        description="Current processing status",
    )
    duration_seconds: float | None = Field(
        default=None, description="Call duration from transcription"
    )
    error_message: str | None = Field(
        default=None, description="Error details if processing failed"
    )
    created_at: datetime = Field(
        default_factory=datetime.utcnow, description="When the call was uploaded"
    )
    updated_at: datetime = Field(
        default_factory=datetime.utcnow, description="Last status change"
    )

    # Relationships - cascade delete transcripts and insights when call is deleted
    transcripts: list["Transcript"] = Relationship(
        back_populates="call",
        sa_relationship_kwargs={"cascade": "all, delete-orphan"},
    )
    insights: list["Insight"] = Relationship(
        back_populates="call",
        sa_relationship_kwargs={"cascade": "all, delete-orphan"},
    )


class Transcript(SQLModel, table=True):
    """
    A single utterance from a call with speaker attribution.

    Speaker diarization splits the call into segments, each attributed
    to a speaker (e.g., "Speaker A", "Speaker B").
    """

    id: int | None = Field(default=None, primary_key=True)
    call_id: int = Field(foreign_key="call.id", index=True)
    speaker: str = Field(description="Speaker label from diarization")
    text: str = Field(description="What was said")
    start_time: int = Field(description="Start time in milliseconds")
    end_time: int = Field(description="End time in milliseconds")
    confidence: float | None = Field(
        default=None, description="Transcription confidence score"
    )

    # Relationship back to parent call
    call: Call = Relationship(back_populates="transcripts")


class Insight(SQLModel, table=True):
    """
    An extracted insight from a call (objection, question, commitment, etc.).

    Insights are generated by LLM analysis of the transcript.
    """

    id: int | None = Field(default=None, primary_key=True)
    call_id: int = Field(foreign_key="call.id", index=True)
    insight_type: InsightType = Field(index=True, description="Category of insight")
    content: str = Field(description="The insight text")
    confidence: float | None = Field(
        default=None, description="LLM confidence in this insight"
    )
    extra_data: dict = Field(
        default_factory=dict,
        sa_column=Column(JSON),
        description="Flexible extra data (like metadata, e.g., sentiment score, timestamps)",
    )
    created_at: datetime = Field(
        default_factory=datetime.utcnow, description="When insight was extracted"
    )

    # Relationship back to parent call
    call: Call = Relationship(back_populates="insights")


# Pydantic Models for API response

class TranscriptRead(SQLModel):
    """Transcript data for API responses."""

    id: int
    call_id: int
    speaker: str
    text: str
    start_time: int
    end_time: int
    confidence: float | None


class InsightRead(SQLModel):
    """Insight data for API responses."""

    id: int
    call_id: int
    insight_type: InsightType
    content: str
    confidence: float | None
    metadata: dict
    created_at: datetime


class CallRead(SQLModel):
    """Call data for API responses (without relationships)."""

    id: int
    filename: str
    original_filename: str
    file_size: int
    status: CallStatus
    duration_seconds: float | None
    error_message: str | None
    created_at: datetime
    updated_at: datetime


class CallReadWithDetails(CallRead):
    """Call data with transcripts and insights for detailed view."""

    transcripts: list[TranscriptRead] = []
    insights: list[InsightRead] = []
